(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{355:function(t,_,v){t.exports=v.p+"assets/img/tcp_head.c8265437.png"},356:function(t,_,v){t.exports=v.p+"assets/img/threeHand.ac6e5101.png"},357:function(t,_,v){t.exports=v.p+"assets/img/fourHand.e1d78216.png"},373:function(t,_,v){"use strict";v.r(_);var r=v(45),n=Object(r.a)({},(function(){var t=this,_=t.$createElement,r=t._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"tcp总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tcp总结"}},[t._v("#")]),t._v(" TCP总结")]),t._v(" "),r("p",[t._v("TCP协议比较复杂，这一篇博客作为笔记，记录TCP中比较重要且容易忘记的点。")]),t._v(" "),r("h3",{attrs:{id:"_1、tcp报文段的首部"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、tcp报文段的首部"}},[t._v("#")]),t._v(" 1、TCP报文段的首部")]),t._v(" "),r("p",[t._v("TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。一个TCP报文段分为首部和数据两部分，而TCP的全部功能都体现在它的首部各字段发挥的作用中。首先引入一张"),r("a",{attrs:{href:"https://baike.baidu.com/item/%E8%B0%A2%E5%B8%8C%E4%BB%81/6146871?fr=aladdin",target:"_blank",rel:"noopener noreferrer"}},[t._v("谢希任"),r("OutboundLink")],1),t._v("教授所著的《计算机网络（第7版）》(下文称为书本) 中的TCP首部插图：")]),t._v(" "),r("p",[r("img",{attrs:{src:v(355),alt:"TCP首部"}})]),t._v(" "),r("p",[t._v("上图已经很清晰的展示了TCP首部中的所有字段的基本信息了，其中主要的几个字段有："),r("strong",[t._v("序号（也叫序列号，通常记为seq）、确认号（通常记为ack）、6个标志位、窗口")]),t._v("，这几个字段的作用如下："),r("br"),t._v("\n⭐️"),r("strong",[t._v("序号")]),t._v("：占4个字节，用来标记报文段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，"),r("strong",[t._v("第一个字节的编号由本地随机产生")]),t._v("；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。"),r("br"),t._v("\n⭐️"),r("strong",[t._v("确认号")]),t._v("：占4个字节，表示期待收到对方下一个报文段的第一个数据字节的序号；由于序号表示报文段携带数据的第一个字节的编号，而确认号指的是期望接收到的下一个字节的编号，"),r("strong",[t._v("因此当前报文段最后一个字节的编号+1即为确认号")]),t._v("。"),r("br"),t._v("\n⭐️"),r("strong",[t._v("6个标志位")]),t._v("：每个标志位占1位，取值是0或1，主要注意这3个标志位：")]),t._v(" "),r("ul",[r("li",[r("strong",[r("code",[t._v("确认位ACK")])]),t._v("：仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效")]),t._v(" "),r("li",[r("strong",[r("code",[t._v("同步位SYN")])]),t._v("：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。")]),t._v(" "),r("li",[r("strong",[r("code",[t._v("终止位FIN")])]),t._v("：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放TCP连接。")]),t._v(" "),r("li",[t._v("用表格描述是如下：\n"),r("table",[r("thead",[r("tr",[r("th",{staticStyle:{"text-align":"center"}},[t._v("字段")]),t._v(" "),r("th",{staticStyle:{"text-align":"left"}},[t._v("含义")])])]),t._v(" "),r("tbody",[r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("ACK")]),t._v(" "),r("td",{staticStyle:{"text-align":"left"}},[t._v("确认号是否有效，一般置为1。")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("SYN")]),t._v(" "),r("td",{staticStyle:{"text-align":"left"}},[t._v("请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("FIN")]),t._v(" "),r("td",{staticStyle:{"text-align":"left"}},[t._v("希望断开连接。")])])])])])]),t._v(" "),r("p",[t._v("⭐️"),r("strong",[t._v("窗口")]),t._v("：占2个字节，指的是发送本报文的段的一方的接收窗口，也就是对方接收到本报文段后能发送的数据量，这个字段是动态变化的。")]),t._v(" "),r("h3",{attrs:{id:"_2、三握四挥"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、三握四挥"}},[t._v("#")]),t._v(" 2、三握四挥")]),t._v(" "),r("p",[t._v("TCP是面向连接的，其经典的三次握手建立连接和四次挥手断开连接也是比较重要的。")]),t._v(" "),r("p",[t._v("🌔"),r("strong",[t._v("三次握手")]),r("br"),t._v("\nTCP的连接建立采用客户服务器方式，主动发起连接的请求的应用进程叫做客户，被动等待连接的应用进程叫做服务器。建立连接的过程叫做握手。再次引用书本中关于三次握手过程的插图：")]),t._v(" "),r("p",[r("img",{attrs:{src:v(356),alt:"三次握手"}})]),t._v(" "),r("p",[t._v("根据上图可描述出三次握手的过程："),r("br"),t._v("\n🤝第一次握手："),r("strong",[t._v("客户端进程向服务器进程发送连接请求报文段")]),t._v("（此时首部中的同步位SYN = 1，序号是随机产生的一个初始序号seq = x。此报文段是SYN报文段），并进入SYN_SENT（"),r("strong",[t._v("同步已发送")]),t._v("）状态，等待服务器确认。"),r("br"),t._v("\n🤝第二次握手："),r("strong",[t._v("服务器进程收到连接请求后")]),t._v("，如果同意（"),r("font",{attrs:{color:"orange"}},[t._v("不同意可能是服务器对应端口未打开？")]),t._v("）的话就"),r("strong",[t._v("向客户端发送确认报文段")]),t._v("（此时首部中SYN位和ACK位都置1，确认号ack = x + 1则表明收到了客户端的请求，同时随机生成一个初始序号seq = y。此报文段既是SYN报文段，也是ACK报文段），发送完后"),r("strong",[t._v("服务器进程")]),t._v("进入SYN-RCVD("),r("strong",[t._v("同步收到")]),t._v(")状态。"),r("br"),t._v(" "),r("font",{attrs:{color:"green"}},[t._v("注意：前2次握手都是不能携带数据的，但都要且仅要消耗一个序号。")]),r("br"),t._v("\n🤝  "),r("strong",[t._v("客户端收到服务器的确认后")]),t._v("，还要向服务器"),r("strong",[t._v("发送确认报文段")]),t._v("（此时首部中的ACK位置1，序号就是seq = x + 1，确认号ack = y + 1。此报文段是ACK报文段），此报文段是允许携带数据的。客户端发送完确认报文段后就进入了ESTABLISHED（"),r("strong",[t._v("已建立连接")]),t._v("）状态，服务器接收到客户端的确认后也进入ESTABLISHED（"),r("strong",[t._v("已建立连接")]),t._v("）状态。"),r("br"),t._v("\n至此连接就建立了。\n"),r("font",{attrs:{color:"green"}},[t._v("上图中服务器进程的CLOSED(关闭)状态其实是表示该服务器进程未被分配端口，分配端口后该进程就会变为且一直处于LISTEN(监听)状态。")])],1),t._v(" "),r("p",[t._v("🌔"),r("strong",[t._v("四次挥手")]),r("br"),t._v("\n在数据传输结束后，通信双方都可以释放连接。依然引用书本中关于TCP连接释放的插图："),r("br"),t._v(" "),r("img",{attrs:{src:v(357),alt:"四次挥手"}}),r("br"),t._v("\n✋第一次挥手："),r("strong",[t._v("客户端进程发出连接释放报文段")]),t._v("，并且停止发送数据。释放数据报文首部中终止控制位FIN=1，其序号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，"),r("strong",[t._v("客户端进程")]),t._v("进入FIN-WAIT-1（"),r("strong",[t._v("终止等待1")]),t._v("）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。"),r("br"),t._v("\n✋第二次挥手："),r("strong",[t._v("服务器进程接收到连接释放报文段后即发出确认")]),t._v("，确认号ack=u+1，并且带上自己的序列号seq=v，此时，"),r("strong",[t._v("服务器进程")]),t._v("就进入了CLOSE-WAIT（"),r("strong",[t._v("关闭等待")]),t._v("）状态，客户端没有数据要发送了，但服务器任可以发送数据。"),r("strong",[t._v("客户端进程接收到服务器进程的确认后")]),t._v("，就进入FIN-WAIT-2（"),r("strong",[t._v("终止等待2")]),t._v("）状态。"),r("br"),t._v(" "),r("font",{attrs:{color:"green"}},[t._v("此时从客户端到服务器这个方向的连接就已经释放了，TCP连接处于半关闭状态。")]),r("br"),t._v("\n✋第三次挥手：若"),r("strong",[t._v("服务器进程")]),t._v("没有要向客户端进程发送数据了，则"),r("strong",[t._v("发出连接释放报文段")]),t._v("（FIN=1），报文段首部中要重复上次已经发送过的确认号ack=u+1，由于在半关闭状态服务器很可能又发送了一些数据，假定此时的序列号为seq=w。此时，"),r("strong",[t._v("服务器进程")]),t._v("就进入了LAST-ACK（"),r("strong",[t._v("最后确认")]),t._v("）状态，等待客户端的确认。"),r("br"),t._v("\n✋第四次挥手："),r("strong",[t._v("客户端进程收到服务器进程的连接释放报文后")]),t._v("，必须"),r("strong",[t._v("发出确认报文段")]),t._v("，报文段首部中确认位ACK=1，确认号ack=w+1，而序号是seq=u+1，此时，"),r("strong",[t._v("客户端进程")]),t._v("就进入了TIME-WAIT（"),r("strong",[t._v("时间等待")]),t._v("）状态。注意此时TCP连接还没有释放，必须"),r("strong",[t._v("经过2MSL（最长报文段寿命）的时间后，客户端")]),t._v("撤销相应的TCB（传输控制块）后，才进入CLOSED（"),r("strong",[t._v("关闭")]),t._v("）状态。而"),r("strong",[t._v("服务器只要收到了客户端发出的确认")]),t._v("，就立即进入CLOSED（"),r("strong",[t._v("关闭")]),t._v("）状态"),r("br"),t._v(" "),r("font",{attrs:{color:"green"}},[t._v("可以看到，服务器结束TCP连接的时间要比客户端早一些。")])],1),t._v(" "),r("p",[t._v("⚠️关于三次握手和四次挥手的常见问题可参考书本和其他"),r("a",{attrs:{href:"https://blog.csdn.net/qq_38950316/article/details/81087809?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.base",target:"_blank",rel:"noopener noreferrer"}},[t._v("博客"),r("OutboundLink")],1),t._v("。")]),t._v(" "),r("h3",{attrs:{id:"_3、可靠传输的原理和实现-待续"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、可靠传输的原理和实现-待续"}},[t._v("#")]),t._v(" 3、可靠传输的原理和实现（待续）")]),t._v(" "),r("ul",[r("li",[t._v("停止等待协议")]),t._v(" "),r("li",[t._v("连续ARQ协议")]),t._v(" "),r("li",[t._v("流量控制（滑动窗口）")]),t._v(" "),r("li",[t._v("拥塞控制（慢开始、拥塞避免、快重传、快恢复）")])])])}),[],!1,null,null,null);_.default=n.exports}}]);